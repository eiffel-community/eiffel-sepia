<!DOCTYPE html>
<html>
  <head>
    <title>Eiffel | Sepia Implementation Architecture | Real Time Event Parsing</title>
    <meta name="theme-color" content="#ffffff">
    <link rel="apple-touch-icon" sizes="180x180" href="./images/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./images/favicon/favicon-16x16.png">
    <link rel="manifest" href="./manifest.json">
    <link rel="mask-icon" href="./images/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel='stylesheet' href='./css/index.css'>
    <meta name="theme-color" content="#ffffff">
    <script src="./js/csi.min.js"></script>
  </head>
  <body class="container">
    <div data-include="includes/header.html"></div>
    <section>
      <div>
        <h1 class="section-heading">Real Time Event Parsing</h1>
        <p class="section-paragraph">The most direct mode of consuming events is through real time parsing of events as they are received from the <a href="rabbitmq-message-broker.html">RabbitMQ Message Broker</a>. This is done as a <a href="https://www.rabbitmq.com/clients.html">RabbitMQ Client</a> consuming messages from a queue. This is a simple and quick method of accessing event data, but with limitations. While queues can be configured to retain messages received while the client is offline, thereby protecting against data loss due to downtime, any events that occurred before the queue was created will be inaccessible. Furthermore, the client will need to take responsibility for storing any event information needed for later use. In simple use cases, these limitations are not problematic. For instance, if all the information one needs is contained within a single Eiffel event, storing event data is not an issue.</p>
        <p class="section-paragraph">Example: Jane needs to start a memory profiling job whenever a new release candidate is published. She listens to <a href="https://github.com/eiffel-community/eiffel/blob/edition-lyon/eiffel-vocabulary/EiffelArtifactPublishedEvent.md">EiffelArtifactPublishedEvent</a> matching he groupId and artifactId of her release candidates, and fetches the artifact at the location included in the event. This is an entirely stateless procedure that is easily implementing by consuming events directly from a RabbitMQ queue.</p>
        <p class="section-paragraph">More advanced use cases, on the other hand, benefit from using <a href="historical-event-lookup.html">Historical Event Lookup</a> and/or <a href="aggregated-event-analysis.html">Aggregated Event Analysis</a> instead.</p>
      </div>
    </section>
    <div data-include="includes/footer.html"></div>
  </body>
</html>
